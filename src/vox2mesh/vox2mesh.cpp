#include <cmath>
#include <fstream>
#include <random>
#include <chrono>
#include <unordered_map>
#include <iostream>

#include <eigen3/Eigen/Dense>
#include "box3d.h"
#include "voxel_loader.h"
#include "mesh_loader.h"
#include "SE3.h"
#include "color_map.h"
#include <vox2mesh.h>

Eigen::MatrixXf box_vertices, box_normals;
Eigen::Matrix<uint32_t, -1, -1> box_elements;

void get_position_and_color_from_vox(
        voxel &vox, PlyMesh &mesh,
        Eigen::Vector3f voxelsize,
        float trunc,
        std::string cmap) {

	std::vector<Eigen::Vector3f> positions;
	std::vector<Eigen::Matrix<uint8_t, 3, 1>> colors;
	int n_voxels = 0;

    if (vox.pdf.size() == 0) {
        vox.pdf.resize(vox.sdf.size());
        std::fill(vox.pdf.begin(), vox.pdf.end(), 1);
    }

	for (int k = 0; k < vox.dims[2]; k++) {
		for (int j = 0; j < vox.dims[1]; j++) {
			for (int i = 0; i < vox.dims[0]; i++) {
				int index = k*vox.dims[1]*vox.dims[0] + j*vox.dims[0] + i;
				if (std::abs(vox.sdf[index]) <= trunc*vox.res) {
					Eigen::Vector3f p;
					p = (vox.grid2world*Eigen::Vector4f(i, j, k, 1)).topRows(3);
					positions.push_back(p);
					Eigen::Vector3f color;
					ColorMap::colormap(vox.pdf[index], color, cmap);
					colors.push_back((255.0f*color).cast<uint8_t>());
					//colors.push_back(Eigen::Vector3f(255, 0, 0));
					n_voxels++;
				}
			}	
		}	
	}

	int n_verts_per_voxel = box_vertices.cols();
	int n_elems_per_voxel = box_elements.cols();
	std::cout << "n_voxels: " << n_voxels << std::endl;

	mesh.V.resize(3, n_voxels*n_verts_per_voxel);
	mesh.C.resize(3, n_voxels*n_verts_per_voxel);
	mesh.N.resize(3, n_voxels*n_verts_per_voxel);
	mesh.F.resize(3, n_voxels*n_elems_per_voxel);

	Eigen::Vector3f res;
	res = 0.45*voxelsize*vox.res;

	for (int i = 0; i < n_voxels; i++) {
		Eigen::Vector3f p = positions[i];

		mesh.V.block(0, i*n_verts_per_voxel, 3, n_verts_per_voxel) = (box_vertices.array().colwise()*res.array()).colwise() + p.array();
		mesh.C.block(0, i*n_verts_per_voxel, 3, n_verts_per_voxel).colwise() = colors[i];
		mesh.N.block(0, i*n_verts_per_voxel, 3, n_verts_per_voxel) = box_normals;
		mesh.F.block(0, i*n_elems_per_voxel, 3, n_elems_per_voxel) = box_elements + Eigen::Matrix<uint32_t, -1, -1>::Constant(3, n_elems_per_voxel, i*n_verts_per_voxel);
	}

}

void write_ply(const std::string & filename, PlyMesh &mesh) {

	std::filebuf fb_binary;
	//fb_binary.open(filename, std::ios::out | std::ios::binary);
	fb_binary.open(filename, std::ios::out);
	std::ostream outstream_binary(&fb_binary);
	if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

	tinyply::PlyFile ply_file;
	typedef tinyply::Type Type;

	ply_file.add_properties_to_element("vertex", { "x", "y", "z" },  Type::FLOAT32, mesh.V.cols(), reinterpret_cast<uint8_t*>((float*)mesh.V.data()), Type::INVALID, 0);

	//ply_file.add_properties_to_element("vertex", { "nx", "ny", "nz" }, Type::FLOAT32, mesh.N.cols(), reinterpret_cast<uint8_t*>(mesh.N.data()), Type::INVALID, 0);
	
	ply_file.add_properties_to_element("vertex", { "red", "green", "blue" },  Type::UINT8, mesh.C.cols(), reinterpret_cast<uint8_t*>(mesh.C.data()), Type::INVALID, 0);

	ply_file.add_properties_to_element("face", { "vertex_indices" }, Type::UINT32, mesh.F.cols(), reinterpret_cast<uint8_t*>(mesh.F.data()), Type::UINT8, 3);

	ply_file.get_comments().push_back("generated by tinyply 2.2");

	// Write a binary file
	ply_file.write(outstream_binary, false);
}

void write_txt(const std::string& filename, voxel &vox){

    std::ofstream fp;
    fp.open(filename);

	for (int k = 0; k < vox.dims[2]; k++) {
		for (int j = 0; j < vox.dims[1]; j++) {
			for (int i = 0; i < vox.dims[0]; i++) {
				int index = k*vox.dims[1]*vox.dims[0] + j*vox.dims[0] + i;
				if (vox.occ_val[index] == 1) {
					// writing a default color value for now
					fp << i << " " << j << " " << k << " 0 169 255\n";
				}
			}
		}
	}

	fp.close();
}

int vox2mesh(std::string vox_file,
        std::string ply_file,
        std::string txt_file,
        bool is_unitless,
        bool redcenter,
        std::string cmap,
        float trunc){
	Box3D::create(box_vertices, box_normals, box_elements);

	voxel vox;
	Eigen::Vector3f voxelsize(1, 1, 1);

	vox = load_vox(vox_file);

	if (is_unitless) {
		Eigen::Vector3f t;
		Eigen::Quaternionf q;
		Eigen::Vector3f s;
		decompose_mat4(vox.grid2world, t, q, s);
		voxelsize = s;
	}

	if (vox.pdf.size() == 0) {
		vox.pdf.resize(vox.sdf.size());
		std::fill(vox.pdf.begin(), vox.pdf.end(), 0);
		if (redcenter) {
			int c = vox.dims(0)/2;
			int dim = vox.dims(0);
			int w = 1;
			for (int i = c - w; i < c + w + 1; i++)
				for (int j = c - w; j < c + w + 1; j++)
					for (int k = c - w; k < c + w + 1; k++)
						vox.pdf[i*dim*dim + j*dim + k] = 1;
		}
	}

	PlyMesh mesh;
	get_position_and_color_from_vox(vox, mesh, voxelsize, trunc, cmap);

	write_ply(ply_file, mesh);
    write_txt(txt_file, vox);

	return 0;
}
